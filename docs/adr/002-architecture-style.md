# ADR 002: Использование архитектуры Modulith (Модульный монолит)

**Статус:** Accepted
**Дата:** YYYY-MM-DD.

## 1. Контекст и проблема
Для старта нового проекта и выстраивания эталонных инженерных практик необходимо выбрать базовую архитектуру. Проект будет постепенно наполняться новым функционалом, поэтому архитектура должна способствовать легкости разработки и тестирования, предотвращая при этом деградацию кодовой базы (превращение в "Big Ball of Mud").

Рассматривались следующие варианты:
* **Традиционный монолит (Слоистая архитектура):** Легко развертывать, но по мере роста проекта границы между предметными областями стираются, что приводит к сильной связности (coupling) и усложняет поддержку.
* **Микросервисы:** Обеспечивают строгую изоляцию, но требуют значительных накладных расходов на инфраструктуру, усложняют сквозное тестирование и транзакционность. На текущем этапе развития проекта это неоправданный оверхед.

Необходим подход, который обеспечит простоту развертывания монолита, но заставит соблюдать строгие границы между логическими модулями на уровне кода.

## 2. Решение
Мы принимаем архитектурный стиль **Модульный монолит (Modulith)** в качестве основы для проекта.

* Приложение будет развертываться и запускаться как единый процесс (одно Spring Boot приложение).
* Внутренняя структура кодовой базы будет разделена на независимые бизнес-модули (по предметным областям).
* Межмодульное взаимодействие будет осуществляться исключительно двумя способами:
  1. Синхронно — через строго определенные публичные API (интерфейсы) модулей.
  2. Асинхронно — через событийно-ориентированную модель (Application Events).
* Прямые вызовы внутренних (internal/private) компонентов других модулей строго запрещены.
* Нарушение архитектурных границ модулей должно отслеживаться и пресекаться автоматически на этапе прогона тестов (например, через интеграцию с тестами архитектуры).

## 3. Последствия

### Положительные:
* **Высокая скорость разработки:** Отсутствие сетевых задержек, сериализации и сложного девопса. Легкий запуск приложения и инфраструктуры локально.
* **Строгая изоляция:** Модули остаются независимыми. Снижается когнитивная нагрузка на разработчика при работе над конкретной фичей.
* **Готовность к масштабированию:** Слабая связность модулей позволит в будущем легко вынести любой из них в полноценный отдельный сервис при возникновении такой необходимости.

### Риски и компромиссы:
* **Единая точка отказа:** Так как это физически один процесс, критическая ошибка (например, OOM) в одном модуле приведет к падению всего приложения.
* **Разделение данных:** Требуется строгая дисциплина в работе с базой данных (PostgreSQL), чтобы модули не обращались к чужим таблицам напрямую, в обход API модуля-владельца.
* **Конфликты зависимостей:** Все модули делят один classpath и версии транзитивных зависимостей.


# [ADR-002] Microservices Architecture

**Status:** Accepted
**Date:** 2024-02-18

## Context
Мы создаем High-Load систему мониторинга криптовалют.
Требования:
* Независимое масштабирование (агрегатор котировок требует много CPU/Network, рассыльщик уведомлений — I/O).
* Отказоустойчивость (падение одного модуля не должно валить всю систему).
* Возможность использования разных технологий.

## Decision
Мы выбираем **Microservices Architecture**.
Система разбивается на автономные сервисы:
1.  `market-data-service` (Ingestion).
2.  `portfolio-manager-service` (Core Domain).
3.  `notification-dispatcher` (Egress).
4.  `shared-kernel` Общий код (DTO, Exceptions, Utils).

Коммуникация:
* Синхронная: REST (WebFlux) для запросов "здесь и сейчас".
* Асинхронная: Message Broker (Kafka/RabbitMQ) для событий (Event-Driven).

## Consequences
**Плюсы:**
* Изоляция сбоев.
* Независимый деплой.
* Четкие границы контекстов (Bounded Contexts).

**Минусы:**
* Сложность инфраструктуры (Docker, K8s, Service Discovery).
* Распределенные транзакции (Saga pattern).
* Сложность отладки (Distributed Tracing).
