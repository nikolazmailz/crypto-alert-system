# [ADR 006] Использование подхода Code-First для документирования API

**Статус:** Принято
**Дата:** 24 февраля 2026 г.

## 1. Контекст и проблема
Для взаимодействия с фронтендом и документирования публичных контрактов модулей (Modulith) нам необходима спецификация OpenAPI (Swagger).
Рассматривались два подхода:
* **API-First (Design-First):** Ручное написание `openapi.yaml` и автогенерация интерфейсов. Обеспечивает строгий контракт, но вносит существенный оверхед (overhead) на этапе разработки и требует настройки плагинов кодогенерации, что замедляет работу небольших команд или соло-разработчиков.
* **Code-First:** Написание кода (контроллеров и DTO) и автоматическая генерация спецификации OpenAPI на основе аннотаций во время работы приложения.

Для текущего этапа развития проекта приоритетом является скорость разработки и минимизация инфраструктурного бойлерплейта при сохранении актуальной документации.

## 2. Решение
Мы принимаем подход **Code-First** в качестве стандарта для описания и документирования REST API.

* **Единый источник истины (Single Source of Truth):** Исходный код на Kotlin (классы контроллеров и DTO) является первичным. Спецификация генерируется из него.
* **Инструментарий:** Для автоматической генерации OpenAPI v3 документации и UI будет использоваться библиотека `springdoc-openapi-starter-webflux-ui` (с поддержкой корутин и WebFlux).
* **Соблюдение Clean Architecture:** Аннотации Swagger (`@Tag`, `@Operation`, `@Schema`, `@ApiResponse`) разрешено использовать **исключительно в слое Controllers** (включая DTO, которые относятся к этому слою). Категорически запрещено добавлять эти аннотации в слой Domain (Core) или Application.
* **Изоляция аннотаций (Best Practice):** Чтобы не засорять логику контроллеров визуальным шумом, рекомендуется выносить аннотации OpenAPI в отдельные Kotlin-интерфейсы, которые затем реализуются контроллерами.

## 3. Последствия

### Положительные:
* **Высокая скорость разработки:** Можно сразу писать код бизнес-фич, документация генерируется бесплатно.
* **Синхронизация:** Документация всегда на 100% соответствует реальному коду, невозможно забыть обновить YAML при изменении DTO.
* **Простота интеграции:** Библиотека `springdoc-openapi` "из коробки" понимает suspend-функции Kotlin, Flow и специфику Spring WebFlux.

### Риски и компромиссы:
* **Загрязнение кода:** DTO и контроллеры обрастают большим количеством инфраструктурных аннотаций.
* **Блокировка параллельной работы:** Клиенты API (фронтенд) не могут получить готовый контракт, пока бэкенд не будет написан и запущен.
* **Сложность ревью контракта:** При Code Review изменения в API размазаны по коду контроллеров и дата-классов, а не собраны в одном наглядном YAML-файле.
